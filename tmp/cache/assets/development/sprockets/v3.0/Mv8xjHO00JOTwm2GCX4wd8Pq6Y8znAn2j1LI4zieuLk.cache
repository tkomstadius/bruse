I"(function() {
  this.bruseApp.directive('bDropzone', function() {
    return {
      restrict: 'A',
      scope: {
        theFiles: '=',
        images: '=',
        drop: '=',
        saved: '=',
        info: '=',
        noType: '='
      },
      link: function(scope, element, attrs) {
        var processDragOverOrEnter;
        processDragOverOrEnter = function(event) {
          if (event != null) {
            event.preventDefault();
          }
          (event.originalEvent || event).dataTransfer.effectAllowed = 'move';
          return false;
        };

        /*addFile = (file) ->
          obj = {}
          obj.name = file.name
          obj.type = file.type
          reader = new FileReader()
          
          reader.onload = (evt) ->
             * update bindings
            scope.$apply ->
              obj.data = reader.result.split(",")[1]
              scope.drop = true
              scope.info = ''
              scope.theFiles.push obj
        
              if file.type in ['image/jpeg', 'image/png', 'image/tiff', 'image/gif']
                scope.images.push evt.target.result
              return
        
          if file.type != ''
            reader.readAsDataURL file
          else
            scope.$apply ->
              scope.noType = scope.noType + file.name + " has no type and can not be saved"
          return false
         */
        element.bind('dragover', processDragOverOrEnter);
        element.bind('dragenter', processDragOverOrEnter);
        return element.bind('drop', function(event) {
          var entries, entry, files, i, items, readEntries, results, temp;
          if (event != null) {
            event.preventDefault();
          }
          items = event.originalEvent.dataTransfer.items;
          files = event.originalEvent.dataTransfer.files;
          scope.noType = '';
          i = 0;
          results = [];
          while (i < items.length) {
            entry = items[i].webkitGetAsEntry();
            if (entry.isFile) {
              temp = [];
              scope.images = [];
              scope.saved = false;
              entry.file(function(file) {
                var obj, reader;
                obj = {};
                obj.name = file.name;
                obj.type = file.type;
                reader = new FileReader();
                reader.onloadend = function(evt) {};
                return scope.$apply(function() {
                  var ref;
                  obj.data = reader.result.split(",")[1];
                  scope.drop = true;
                  scope.info = '';
                  scope.theFiles.push(obj);
                  if ((ref = file.type) === 'image/jpeg' || ref === 'image/png' || ref === 'image/tiff' || ref === 'image/gif') {
                    scope.images.push(evt.target.result);
                  }
                });
              }, file.type !== '' ? reader.readAsDataURL(file) : scope.$apply(function() {
                return scope.noType = scope.noType + file.name + " has no type and can not be saved";
              }));

              /*temp = []
              scope.images = []
              scope.saved = false
              addFile(files[i])
               */
            } else if (entry.isDirectory) {
              entries = [];
              readEntries = function(entry) {
                var dirReader;
                dirReader = entry.createReader();
                return dirReader.readEntries();
              };
            }
            results.push(i++);
          }
          return results;
        });
      }
    };
  });

}).call(this);
:ET