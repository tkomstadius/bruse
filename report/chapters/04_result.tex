\chapter{Resultat}

\section{Installation av systemet}
Ett av kraven från kunden var att kunna installera systemet på sin egna server
och låta det köra därifrån. För att underlätta för kunden vid installationen
skapades en installationsfil som laddar ner systemets filer, fixar inställningar
för databasen och även ställer frågor om vilka tredjepartstjänster som ska
användas. Installationsfilen anpassar sedan systemet utefter de svar som fås av
användaren vid installation. Stegen demonstreras i bild \ref{fig:installation}.

\begin{figure}[!h]
\centering
\includegraphics[width=0.8\textwidth]{figures/installation.png}
\caption{De steg som installationsfilen tar för att installera systemet.}
\label{fig:installation}
\end{figure}

\section{Systemarkitektur}

\subsection{Ruby on rails}
Följande modeller valdes att användas för systemet. Relationerna mellan de är
specificerade i bild \ref{fig:models}. Modellen \texttt{BruseFile} fick det namnet
eftersom \emph{File} är ett reserverat ord i Ruby och lösningen blev då att
lägga till \emph{bruse}.

\begin{figure}[!h]
\centering
\includegraphics[width=0.8\textwidth]{figures/models.png}
\caption{De \emph{models} som finns i systemet.}
\label{fig:models}
\end{figure}

\texttt{Identity} är en av systemets viktigaste models. En \texttt{Identity} är en av
tredjepartstjänsterna Google Drive eller Dropbox. Men även den egna filhantering
hanteras som en \texttt{Identity} för att hålla det konsekvent och modulärt.

För att kunna presentera en fil och dess taggar äger \texttt{BruseFile} flera
taggar, men för att även kunna lista filer beroende på en tagg äger varje tagg
flera \texttt{BruseFiles}. Rails löser relationen mellan dessa två genom att skapa
en tabell som heter \texttt{bruse\_files\_tags} enligt bild
\ref{fig:bruse_files_tags}.

\begin{figure}[!h]
\centering
\includegraphics[width=0.2\textwidth]{figures/bruse_files_tags.png}
\caption{Relationen mellan \texttt{BruseFiles} och \texttt{Tags} i databasen.}
\label{fig:bruse_files_tags}
\end{figure}

I systemet finns det flera \emph{controllers} för att hantera logiken. Varje
\emph{model} har en \emph{controller}, men \texttt{bruse\_file} delades upp i tre
då den innehåller all logik kring uppladdning, nerladdning, visa filer, lista
med mera.

\subsection{Angularjs}
De områden som styrs utav Angularjs är:
\begin{itemize}
  \item Lägga till filer
  \item Lägga till taggar till nyligen tillagda filer
  \item Söka efter filer
  \item Skapa filer från text
  \item Dra och släpp-uppladdning
  \item Lista filer
\end{itemize}

För att inte behöva upprepa kod och istället återanvända logik för exempelvis
hämta och spara information kring filer eller taggar, skapades funktioner som
delas av flera av systemets komponenter.

\section{Tredjepartsmjukvara}

Devise är ett tillägg till Ruby on rails som ger ett paket för
användarhantering, färdigt att användas. Då beslutet om att användare även
skulle kunna logga in med e-postadress och lösenord insågs det samtidigt att en
tredjeparts-tjänst skulle vara nödvändigt för att hålla tidsramen. Devise valdes
för att det gav den mest kompletta lösningen med färdiga vyer, modifierbara
\emph{controllers} och enkel \emph{model}-påbyggnad.

Carrierwave ger utvecklarna verktyg för att hantera uppladdningen av filer.
Genom att endast specificera inställningar för var filen ska sparas och så
vidare fås en modul som kan användas i de \emph{controller}-metoder som behövs.

Fuzzily skapar för varje ny instans av specificerade models \emph{trigrams} över valda
kolumner. \emph{Trigrams} delar upp ett ord och grupperar det tre tecken i
taget[Gencosman, BC, Ozmutlu, HC, \& Ozmutlu, S 2014]. För varje ny gruppering
förflyttas den ett steg vilket gör att det skapas flera olika kombinationer. För
ett ord skulle det resultera i flera olika bokstavskombinationer av grundordet.
Exempelvis skulle ordet “bruse” med hjälp av \emph{trigrams} bli [b, br, bru, rus, use,
se, e]. Under implementationen av Fuzzily upptäcktes det att numeriska eller
nordiska tecken inte sparades i \emph{trigrams}. Tack vare att Fuzzily är skrivet i
öppen källkod kunde problemet åtgärdas genom att ändra koden.

Jstag är ett tillägg till Angularjs som konverterar användarens inskrivning utav
taggar till visuella objekt för att tydliggöra för användaren hur dess
inskrivning tolkas utav systemet. Även detta tillägg hade brister i koden som
kunde åtgärdas tack vare att det var skrivet med öppen källkod.

\section{Hantering och strukturering av databaser}

Den första versionen av databasen hade följande struktur:
\begin{itemize}
\item User
  \begin{itemize}
    \item id (heltal, unik nyckel)
    \item name (sträng, användarens namn)
  \end{itemize}
\item Identity
  \begin{itemize}
    \item id (heltal, unik nyckel)
    \item user\_id (heltal, referens till användare)
    \item service (sträng, till exempel “Dropbox”)
    \item token (sträng, nyckel som används för kontakt med extern API)
  \end{itemize}
\item BruseFile
  \begin{itemize}
    \item id (heltal, unik nyckel)
    \item identity\_id (heltal, referens till identity)
    \item name (sträng, filens namn)
    \item foreign\_ref (sträng, hur den externa tjänsten har koll på filerna)
    \item filetype (sträng, filens typ)
    \item meta (sträng, extra information om filen)
  \end{itemize}
\item Tag
  \begin{itemize}
    \item id (heltal, unik nyckel)
    \item name (sträng, nyckelordet)
  \end{itemize}
\item FileTag
  \begin{itemize}
    \item file\_id (heltal, referens till fil)
    \item tag\_id (heltal, referens till nyckelord)
  \end{itemize}
\end{itemize}

\section{Filhantering}

Då en fil lagrades i systemet är det två attribut som var centrala. Dels
varifrån filen sparats – om den importerades från en extern tjänst som Google
Drive eller Dropbox, eller om den lagrades i systemets lokala fillagring. Vidare
sparas också en textsträng som motsvarar hur den aktuella tjänsten som filen
tillhör separerar filen från övriga filer . Denna textsträng kallas i systemet
för \texttt{foreign\_ref}. För Google Drive är detta en slumpmässig bokstavs- och
sifferkombination, för Dropbox är detta sökvägen till filen. För den lokala
filhanteringen är detta namnet på filen efter att den sparats på servern, också
detta en slumpad bokstavs- och sifferkombination.

\section{Gränssnitt}

\section{Testning}

De tester som utvecklarna lade mest tid på att implementera var tester för
\emph{models}, \emph{controllers} men även integrationstester.
Integrationstester är tester som testar ett användarbeteende och har väldigt
enkla instruktioner, till exempel gå till startsidan och fyll
inloggningsformuläret med dessa uppgifter och tryck sedan på logga in. Med dessa
tester fås en helhetsblick och väldigt stor del av systemet testas i ett och
samma test.

\section{Utvecklingsmetodik}

Arbetet följde Scrum som utvecklingsmetodik vilket har resulterat i en tydlig
och strukturerad arbetsgång. Korta Scrummöten i början av varje arbetsdag har
förhindrat onödigt arbete samt att alla utvecklare är insatta i arbetet. Varje
sprints sprintgranskning och sprintåterblick har givit en tydlig bild om vad som
gjorts och behöver göras för att nå nästa förbättring av produkten.

\section{Versionshantering och kodgranskning}
